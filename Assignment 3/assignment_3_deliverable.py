# -*- coding: utf-8 -*-
"""Assignment_3 Deliverable.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QN2LYOhLSEcrP1fN73qHzOgnbOO9bBCC

Question 1. Python program to create KNN Classification on Iris dataset.
"""

import numpy as np
import pandas as pd

dataset = pd.read_csv('iris.csv')

dataset.head(5)

dataset.describe()

dataset.groupby('Species').size()

#Splitting the features and labels
feature_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm','PetalWidthCm']
X = dataset[feature_columns].values
y = dataset['Species'].values

#converting into numbers as Knn Classifier does not accept strings
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
y = le.fit_transform(y)

#splitting dataset into training set and test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Commented out IPython magic to ensure Python compatibility.
#Data Visualization
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

#Creating plot
from pandas.plotting import parallel_coordinates
plt.figure(figsize=(15,10))
parallel_coordinates(dataset.drop("Id", axis=1), "Species")
plt.title('Parallel Coordinates Plot', fontsize=20, fontweight='bold')
plt.xlabel('Features', fontsize=15)
plt.ylabel('Features values', fontsize=15)
plt.legend(loc=1, prop={'size': 15}, frameon=True,shadow=True, facecolor="white", edgecolor="black")
plt.show()

#This plot above represents attributes. for example every line segment is an attribute.
#One set of connected line segments represents one data point.
# Points that tend to cluster will appear closer together.

"""Question 2. Computing steady state probabilities."""

import numpy as np

one_step_transition = np.array([[0.6     , 0.1, 0.1, 0.2      ],
       [0.2      , 0.6, 0.1,  0.1      ],
       [0.2     , 0.4, 0.1, 0.3        ],
       [0.1,       0.5,  0.2, 0.2]])


def steady_state_prop(p):
    dim = p.shape[0]
    q = (p-np.eye(dim))
    ones = np.ones(dim)
    q = np.c_[q,ones]
    QTQ = np.dot(q, q.T)
    bQT = np.ones(dim)
    return np.linalg.solve(QTQ,bQT)

steady_state_matrix = steady_state_prop(one_step_transition.transpose())

print (steady_state_matrix)